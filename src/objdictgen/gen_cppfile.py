"""Generate CPP file containing a modern representation of index/subindex pairs from a object dictionary node for canfestival."""
"""Structure of generate_file_content taken from gen_cfile.py"""
#
# Copyright (C) 2025-2025  Ronald Kaczynski, Laerdal Medical AS
# Copyright (C): Edouard TISSERANT, Francis DUPIN
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
# USA
#from __future__ import annotations

import re
from collections import UserDict
import copy
from dataclasses import dataclass
from pathlib import Path
from typing import Any

from objdictgen.maps import OD
from objdictgen.typing import NodeProtocol, TODValue, TPath
from objdictgen.gen_cfile import TypeInfos, Text, CFileContext, format_name, compute_value, convert_from_canopen_to_c_type

RE_WORD = re.compile(r'([a-zA-Z_0-9]*)')
RE_TYPE = re.compile(r'([\_A-Z]*)([0-9]*)')
RE_RANGE = re.compile(r'([\_A-Z]*)([0-9]*)\[([\-0-9]*)-([\-0-9]*)\]')
RE_STARTS_WITH_DIGIT = re.compile(r'^(\d.*)')
RE_NOTW = re.compile(r"[^\w]")

CATEGORIES: list[tuple[str, int, int]] = [
    ("SDO_SVR", 0x1200, 0x127F), ("SDO_CLT", 0x1280, 0x12FF),
    ("PDO_RCV", 0x1400, 0x15FF), ("PDO_RCV_MAP", 0x1600, 0x17FF),
    ("PDO_TRS", 0x1800, 0x19FF), ("PDO_TRS_MAP", 0x1A00, 0x1BFF)
]
INDEX_CATEGORIES = ["firstIndex", "lastIndex"]

FILE_HEADER = """
/* File generated by gen_cppfile.py. Should not be modified. */
"""

def generate_file_content(node: NodeProtocol, headerfile: str, no_can_festival: bool, pointers_dict=None) -> tuple[str, str, str, str, str]:
    # FIXME: Too many camelCase vars in here
    # pylint: disable=invalid-name

    # Setup the main context to store the data
    ctx = CFileContext()

    pointers_dict = pointers_dict or {}
    ctx["maxPDOtransmit"] = 0
    ctx["NodeName"] = node.Name
    ctx["NodeID"] = node.ID
    ctx["NodeType"] = node.Type
    ctx["Description"] = node.Description or ""
    ctx["iam_a_slave"] = 1 if node.Type == "slave" else 0

    ctx.default_string_size = node.DefaultStringSize

    # Compiling lists of indexes
    rangelist = [idx for idx in node.GetIndexes() if 0 <= idx <= 0x260]
    listindex = [idx for idx in node.GetIndexes() if 0x1000 <= idx <= 0xFFFF]
    communicationlist = [idx for idx in node.GetIndexes() if 0x1000 <= idx <= 0x11FF]
    # sdolist = [idx for idx in node.GetIndexes() if 0x1200 <= idx <= 0x12FF]
    # pdolist = [idx for idx in node.GetIndexes() if 0x1400 <= idx <= 0x1BFF]
    variablelist = [idx for idx in node.GetIndexes() if 0x2000 <= idx <= 0xBFFF]

    # --------------------------------------------------------------------------
    #        Creation of the mapped variables and object dictionary
    # --------------------------------------------------------------------------

    mappedVariableContent = ctx.text()
    pointedVariableContent = ctx.text()
    strDeclareHeader = ctx.text()
    oldHeaderObjDefinitionContent = ctx.text()
    headerObjDefinitionContent = ctx.text()
    headerObjDefinitionContent += "\n#include <cstdint>\n"
    headerObjDefinitionContent += "#include <tuple>\n"
    headerObjDefinitionContent += "#include <string>\n"
    headerObjDefinitionContent %= """
struct {NodeName} \n{{
"""
    for index in listindex:
        ctx["index"] = index
        entry_infos = node.GetEntryInfos(index)
        params_infos = node.GetParamsEntry(index)
        ctx["EntryName"] = entry_infos["name"]
        values = node.GetEntry(index)

        # Entry type is VAR
        if not isinstance(values, list):
            # FIXME: It is assumed that the type of GetParamsEntry() follows the object type
            #        of GetEntry()
            assert not isinstance(params_infos, list)
            subentry_infos = node.GetSubentryInfos(index, 0)
            typename = node.GetTypeName(subentry_infos["type"])
            typeinfos = ctx.get_valid_type_infos(typename, [values])
            if typename == "DOMAIN" and index in variablelist:
                if not typeinfos.size:
                    raise ValueError(f"Domain variable not initialized, index: 0x{index:04X}, subindex: 0x00")
            ctx["subIndexType"] = typeinfos.type
            if typeinfos.size is not None:
                if params_infos["buffer_size"]:
                    ctx["suffix"] = f"[{params_infos['buffer_size']}]"
                else:
                    ctx["suffix"] = f"[{typeinfos.size}]"
            else:
                ctx["suffix"] = ""
            ctx["value"], ctx["comment"] = compute_value(values, typeinfos.ctype)
            if index in variablelist:
                ctx["name"] = RE_STARTS_WITH_DIGIT.sub(r'_\1', format_name(subentry_infos["name"]))
            values = [values]
        else:
            subentry_infos = node.GetSubentryInfos(index, 0)
            typename = node.GetTypeName(subentry_infos["type"])
            typeinfos = ctx.get_valid_type_infos(typename)
            ctx["value"] = values[0] if index != 0x1003 else 0
            ctx["subIndexType"] = typeinfos.type

            # Entry type is ARRAY
            if entry_infos["struct"] & OD.IdenticalSubindexes:
                subentry_infos = node.GetSubentryInfos(index, 1)
                typename = node.GetTypeName(subentry_infos["type"])
                typeinfos = ctx.get_valid_type_infos(typename, values[1:])
                ctx["subIndexType"] = typeinfos.type
                if typeinfos.size is not None:
                    ctx["suffix"] = f"[{typeinfos.size}]"
                    ctx["type_suffix"] = "*"
                else:
                    ctx["suffix"] = ""
                    ctx["type_suffix"] = ""
                ctx["length"] = values[0]
                if index in variablelist:
                    ctx["name"] = RE_STARTS_WITH_DIGIT.sub(r'_\1', format_name(entry_infos["name"]))
                    ctx["values_count"] = str(len(values) - 1)

                ctx["parent"] = RE_STARTS_WITH_DIGIT.sub(r'_\1', format_name(entry_infos["name"]))
                # Entry type is RECORD
                for subindex, value in enumerate(values):
                    ctx["subindex"] = subindex
                    # FIXME: Are there any point in calling this for subindex 0?
                    params_infos = node.GetParamsEntry(index, subindex)
                    # FIXME: Assumed params_info type is coherent with entry_infos["struct"]
                    assert not isinstance(params_infos, list)
                    if subindex > 0:
                        subentry_infos = node.GetSubentryInfos(index, subindex)
                        typename = node.GetTypeName(subentry_infos["type"])
                        typeinfos = ctx.get_valid_type_infos(typename, [values[subindex]])
                        ctx["subIndexType"] = typeinfos.type
                        if typeinfos.size is not None:
                            if params_infos["buffer_size"]:
                                ctx["suffix"] = f"[{params_infos['buffer_size']}]"
                            else:
                                ctx["suffix"] = f"[{typeinfos.size}]"
                        else:
                            ctx["suffix"] = ""
                        ctx["value"], ctx["comment"] = compute_value(value, typeinfos.ctype)
                        ctx["name"] = format_name(subentry_infos["name"])

        # write index define
        entryName = f"{RE_NOTW.sub('', ctx['EntryName']).strip()}"
        shortEntryName = entryName.replace(ctx['EntryName'], '')
        headerObjDefinitionContent += (
            f"\tstruct {entryName}\n\t{{\n"
            f"\t\tstatic constexpr uint32_t {'' if shortEntryName == entryName else shortEntryName}Index {{{ctx['index']:#04x}}};\n"
            f"\t\tstatic constexpr std::string_view Name = \"{entryName}Index\";\n\n"
        )

        oldHeaderObjDefinitionContent += (
            f"\n#define {RE_NOTW.sub('_', ctx['NodeName'])}"
            f"_{RE_NOTW.sub('_', ctx['EntryName'])}_Idx {ctx['index']:#04x}\n"
        )

        # write subindex defines
        generateSubIndexArrayComment = True
        for subindex, _ in enumerate(values):
            subentry_infos = node.GetSubentryInfos(index, subindex)
            params_infos = node.GetParamsEntry(index, subindex)
            typeinfos = ctx.get_valid_type_infos(typename, [values])
            subindex_type = convert_from_canopen_to_c_type(typeinfos.ctype) if typeinfos.ctype != "visible_string" else "std::string"
            if not entry_infos["struct"] & OD.IdenticalSubindexes:
                generateSubIndexArrayComment = True
                oldHeaderObjDefinitionContent += (
                    f"#define {RE_NOTW.sub('_', ctx['NodeName'])}"
                    f"_{RE_NOTW.sub('_', ctx['EntryName'])}"
                    f"_{RE_NOTW.sub('_', subentry_infos['name'])}"
                    f"_sIdx {subindex:#04x}"
                )
            
                subindexName = RE_NOTW.sub('', subentry_infos['name'])
                if len(values) > 1:
                    headerObjDefinitionContent += (
                        f"\t\tstruct {subindexName}{"Subindex" if subindexName == entryName else ""}\n"
                        f"\t\t{{\n"
                        f"\t\t\tusing DataType = {subindex_type};\n"
                        f"\t\t\tDataType m_Value;\n\n"
                        f"\t\t\tstatic constexpr auto get()\n\t\t\t{{\n"
                        f"\t\t\t\treturn std::make_tuple(Index, Subindex, OdName, Name, sIdxName);\n\t\t\t}}\n\n"
                        f"\t\t\tstatic constexpr uint32_t Subindex {{{subindex:#04x}}};\n"
                        f"\t\t\tstatic constexpr std::string_view sIdxName = \"{subindexName}Subindex\";"
                        f"\n\t\t}};"
                    )
                else:
                    headerObjDefinitionContent += (
                        f"\t\tusing DataType = {subindex_type};\n"
                        f"\t\tDataType m_Value;\n\n"
                        f"\t\tstatic constexpr auto get()\n\t\t{{\n"
                        f"\t\t\treturn std::make_tuple(Index, Subindex, OdName, Name, sIdxName);\n\t\t}}\n\n"
                        f"\t\tstatic constexpr uint32_t Subindex {{{subindex:#04x}}};\n"
                        f"\t\tstatic constexpr std::string_view sIdxName = \"{subindexName}Subindex\";"
                    )
                if params_infos["comment"]:
                    headerObjDefinitionContent += " /*" + params_infos["comment"] + "*/\n"
                    oldHeaderObjDefinitionContent += " /*" + params_infos["comment"] + "*/\n"
                else:
                    headerObjDefinitionContent += "\n"
                    oldHeaderObjDefinitionContent += "\n"
            elif generateSubIndexArrayComment:
                generateSubIndexArrayComment = False
                # Generate Number_of_Entries_sIdx define and write comment
                # about not generating defines for the rest of the array objects
                oldHeaderObjDefinitionContent += (
                    f"#define {RE_NOTW.sub('_', ctx['NodeName'])}"
                    f"_{RE_NOTW.sub('_', ctx['EntryName'])}"
                    f"_{RE_NOTW.sub('_', subentry_infos['name'])}"
                    f"_sIdx {subindex:#04x}\n"
                )
                headerObjDefinitionContent += (
                    f"\t\tusing DataType = {subindex_type};\n"
                    f"\t\tDataType m_Value;\n\n"
                    f"\t\tstatic constexpr auto get()\n\t\t{{\n"
                    f"\t\t\treturn std::make_tuple(Index, Subindex, OdName, Name, sIdxName);\n\t\t}}\n\n"
                    f"\t\tstatic constexpr uint32_t Subindex {{{subindex:#04x}}};\n"
                    f"\t\tstatic constexpr std::string_view sIdxName = \"{subindexName}Subindex\";"
                )

                headerObjDefinitionContent += " /*subindex struct not generated for array objects*/\n\n"
                oldHeaderObjDefinitionContent += " /*subindex struct not generated for array objects*/\n\n"
        headerObjDefinitionContent += "\t};\n\n"
    headerObjDefinitionContent += f"\tstatic constexpr std::string_view OdName = \"{ctx["NodeName"]}\";\n"
    headerObjDefinitionContent += "};\n"


    # --------------------------------------------------------------------------
    #                        Write File Content
    # --------------------------------------------------------------------------
    fileContent = ctx.text(FILE_HEADER)
    fileContent += f"""
#include "{headerfile}"
"""

    fileContent += """
/**************************************************************************/
/* Declaration of mapped variables                                        */
/**************************************************************************/
"""
    fileContent += mappedVariableContent

    # --------------------------------------------------------------------------
    #                      Write Header File Content
    # --------------------------------------------------------------------------
    ctx["file_include_name"] = headerfile.replace(".", "_").upper()
    headerFileContent = ctx.text(FILE_HEADER)
    headerFileContent %= """
#ifndef {file_include_name}
#define {file_include_name}


"""
    headerFileContent += strDeclareHeader
    headerFileContent %= "\n#endif // {file_include_name}\n"

    # --------------------------------------------------------------------------
    #                      Write Header Object Defintions Content
    # --------------------------------------------------------------------------
    file_include_objdef_name = headerfile.replace(".", "_OBJECTDEFINES_").upper()
    headerObjectDefinitionContent = ctx.text(FILE_HEADER)
    headerObjectDefinitionContent += f"""
#ifndef {file_include_objdef_name}
#define {file_include_objdef_name}

/*
    Object defines naming convention:
    General:
        * All characters in object names that does not match [a-zA-Z0-9_] will be replaced by '_'.
        * Case of object dictionary names will be kept as is.
    Index : Node object dictionary name +_+ index name +_+ Idx
    SubIndex : Node object dictionary name +_+ index name +_+ subIndex name +_+ sIdx
*/
"""
    headerObjectDefinitionContent += headerObjDefinitionContent
    headerObjectDefinitionContent += f"\n //---- OLD DEFINES ---- \n\n"
    headerObjectDefinitionContent += oldHeaderObjDefinitionContent
    headerObjectDefinitionContent += f"""
#endif /* {file_include_objdef_name} */
"""

    return str(fileContent), str(headerFileContent), str(headerObjectDefinitionContent)


# ------------------------------------------------------------------------------
#                             Main Function
# ------------------------------------------------------------------------------

def GenerateFile(filepath: TPath, node: NodeProtocol, no_can_festival, pointers_dict=None):
    """Main function to generate the C file from a object dictionary node."""
    filepath = Path(filepath)
    headerpath = filepath.with_suffix(".h")
    headerdefspath = Path(headerpath.parent / (headerpath.stem + "_objectdefines.h"))
    content, header, header_defs = generate_file_content(
        node, headerpath.name, no_can_festival, pointers_dict,
    )

    # Write object definitions header
    with open(headerdefspath, "w", encoding="utf-8") as f:
        f.write(header_defs)

    return

    # Write main .c contents
    with open(filepath, "w", encoding="utf-8") as f:
        f.write(content)

    # Write main .c contents with canfestival types and includes omitted
    if no_can_festival:
        filepath = filepath.with_name(f"{filepath.stem}_no_can_festival{filepath.suffix}")
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(noCanFestivalContent)

    # Write header file
    with open(headerpath, "w", encoding="utf-8") as f:
        f.write(header)

    # Write header file with canfestival types and includes omitted
    if no_can_festival:
        headerpath = headerpath.with_name(f"{headerpath.stem}_no_can_festival{headerpath.suffix}")
        with open(headerpath, "w", encoding="utf-8") as f:
            f.write(noCanFestivalHeader)


